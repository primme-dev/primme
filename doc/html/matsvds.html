

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MATLAB Interface &mdash; PRIMME 3.2.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/extra.css?v=00826961" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=7895512d"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parameter Description" href="appendixsvds.html" />
    <link rel="prev" title="Python Interface" href="pysvds.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #343131" >

          
          
          <a href="readme.html">
            
              <img src="_static/logo-grey.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">PRIMME: PReconditioned Iterative MultiMethod Eigensolver</a></li>
<li class="toctree-l1"><a class="reference internal" href="apieigs.html">Eigenvalue Problems</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apisvds.html">Singular Value Problems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="svdsc.html">C Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="svdsf77.html">FORTRAN Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="svdsf90.html">FORTRAN 90 Library Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pysvds.html">Python Interface</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html">Parameter Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html#preset-methods">Preset Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="appendixsvds.html#error-codes">Error Codes</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #343131" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="readme.html">PRIMME</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="readme.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="apisvds.html">Singular Value Problems</a></li>
      <li class="breadcrumb-item active">MATLAB Interface</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/matsvds.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="pysvds.html" class="btn btn-neutral float-left" title="Python Interface" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="appendixsvds.html" class="btn btn-neutral float-right" title="Parameter Description" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="matlab-interface">
<h1>MATLAB Interface<a class="headerlink" href="#matlab-interface" title="Link to this heading"></a></h1>
<dl class="mat function">
<dt class="sig sig-object mat">
<span class="sig-name descname"><span class="pre">function</span> <span class="pre">[varargout]</span> <span class="pre">=</span> <span class="pre">primme_svds(varargin)</span></span></dt>
<dd><p><code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_svds()</span></code> finds a few singular values and vectors of a matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>
by calling <a class="reference external" href="https://github.com/primme/primme">PRIMME</a>. <code class="docutils literal notranslate"><span class="pre">A</span></code> is typically large and sparse.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A)</span></code> returns a vector with the 6 largest singular values of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(AFUN,M,N)</span></code> accepts the function handle <code class="docutils literal notranslate"><span class="pre">AFUN</span></code> to perform
the matrix vector products with an M-by-N matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.
<code class="docutils literal notranslate"><span class="pre">AFUN(X,'notransp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">A*X</span></code> while <code class="docutils literal notranslate"><span class="pre">AFUN(X,'transp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">A’*X</span></code>.
In all the following, <code class="docutils literal notranslate"><span class="pre">A</span></code> can be replaced by <code class="docutils literal notranslate"><span class="pre">AFUN,M,N</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k)</span></code> computes the <code class="docutils literal notranslate"><span class="pre">k</span></code> largest singular values of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma)</span></code> computes the <code class="docutils literal notranslate"><span class="pre">k</span></code> singular values closest to the
scalar shift <code class="docutils literal notranslate"><span class="pre">sigma</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is a vector, find the singular value <code class="docutils literal notranslate"><span class="pre">S(i)</span></code> closest to each <code class="docutils literal notranslate"><span class="pre">sigma(i)</span></code>, for <code class="docutils literal notranslate"><span class="pre">i&lt;=k</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, it computes the largest singular values.</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">'S'</span></code>, it computes the smallest singular values.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS)</span></code> specifies extra solver parameters.
Some default values are indicated in brackets {}:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.aNorm" title="primme_svds_params.aNorm"><code class="xref c c-member docutils literal notranslate"><span class="pre">aNorm</span></code></a>:    estimation of the 2-norm of <code class="docutils literal notranslate"><span class="pre">A</span></code> {0.0 (estimate the norm internally)}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tol</span></code>:     convergence tolerance <code class="docutils literal notranslate"><span class="pre">NORM([A*V-U*S;A'*U-V*S])</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">NORM(A)</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.eps" title="primme_svds_params.eps"><code class="xref c c-member docutils literal notranslate"><span class="pre">eps</span></code></a>) { <code class="docutils literal notranslate"><span class="pre">1e-10</span></code> for double precision and <code class="docutils literal notranslate"><span class="pre">1e-3</span></code> for single precision}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxit</span></code>:   maximum number of matvecs with <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">A'</span></code> (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxMatvecs" title="primme_svds_params.maxMatvecs"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxMatvecs</span></code></a>)  {inf}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>:       maximum basis size (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBasisSize" title="primme_svds_params.maxBasisSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxBasisSize</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reportLevel</span></code>: reporting level (0-3) (see HIST) {no reporting 0}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">display</span></code>: whether displaying reporting on screen (see HIST) {0 if HIST provided}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isreal</span></code>:  if 0, the matrix is complex; else it’s real {0: complex}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isdouble</span></code>: if 0, the matrix is single; else it’s double {1: double}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>:  which equivalent eigenproblem to solve</p>
<blockquote>
<div><ul class="simple">
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_normalequations" title="primme_svds_preset_method.primme_svds_normalequations"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_normalequations</span></code></a>’: <code class="docutils literal notranslate"><span class="pre">A'*A</span></code> or <code class="docutils literal notranslate"><span class="pre">A*A'</span></code></p></li>
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_augmented" title="primme_svds_preset_method.primme_svds_augmented"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_augmented</span></code></a>’: <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">A';A</span> <span class="pre">0]</span></code></p></li>
<li><p>‘<a class="reference internal" href="appendixsvds.html#c.primme_svds_preset_method.primme_svds_hybrid" title="primme_svds_preset_method.primme_svds_hybrid"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme_svds_hybrid</span></code></a>’: first normal equations and then augmented (default)</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">u0</span></code>:       initial guesses to the left singular vectors (see <a class="reference internal" href="appendixsvds.html#c.primme_svds_params.initSize" title="primme_svds_params.initSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">initSize</span></code></a>) {[]}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">v0</span></code>:       initial guesses to the right singular vectors {[]}</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">orthoConst</span></code>: external orthogonalization constraints (see <code class="xref c c-member docutils literal notranslate"><span class="pre">numOrthoConst</span></code>) {[]}</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.locking" title="primme_svds_params.locking"><code class="xref c c-member docutils literal notranslate"><span class="pre">locking</span></code></a>:  1, hard locking; 0, soft locking</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.maxBlockSize" title="primme_svds_params.maxBlockSize"><code class="xref c c-member docutils literal notranslate"><span class="pre">maxBlockSize</span></code></a>: maximum block size</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.iseed" title="primme_svds_params.iseed"><code class="xref c c-member docutils literal notranslate"><span class="pre">iseed</span></code></a>:    random seed</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primme" title="primme_svds_params.primme"><code class="xref c c-member docutils literal notranslate"><span class="pre">primme</span></code></a>:   options for first stage solver</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.primmeStage2" title="primme_svds_params.primmeStage2"><code class="xref c c-member docutils literal notranslate"><span class="pre">primmeStage2</span></code></a>: options for second stage solver</p></li>
<li><p><a class="reference internal" href="appendixsvds.html#c.primme_svds_params.convTestFun" title="primme_svds_params.convTestFun"><code class="xref c c-member docutils literal notranslate"><span class="pre">convTestFun</span></code></a>: function handler with an alternative convergence criterion.
If <code class="docutils literal notranslate"><span class="pre">FUN(SVAL,LSVEC,RSVEC,RNORM)</span></code> returns a nonzero
value, the triplet <code class="docutils literal notranslate"><span class="pre">(SVAL,LSVEC,RSVEC)</span></code> with residual norm <code class="docutils literal notranslate"><span class="pre">RNORM</span></code>
is considered converged.</p></li>
</ul>
</div></blockquote>
<p>The available options for <code class="docutils literal notranslate"><span class="pre">OPTIONS.primme</span></code> and <code class="docutils literal notranslate"><span class="pre">primmeStage2</span></code> are
the same as <code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_eigs()</span></code>, plus the option <code class="docutils literal notranslate"><span class="pre">'method'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P)</span></code> applies a preconditioner <code class="docutils literal notranslate"><span class="pre">P</span></code> as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a matrix it applies <code class="docutils literal notranslate"><span class="pre">P\X</span></code> and <code class="docutils literal notranslate"><span class="pre">P'\X</span></code> to approximate <code class="docutils literal notranslate"><span class="pre">A\X</span></code> and <code class="docutils literal notranslate"><span class="pre">A'\X</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a function handle, <code class="docutils literal notranslate"><span class="pre">PFUN</span></code>, <code class="docutils literal notranslate"><span class="pre">PFUN(X,'notransp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">P\X</span></code> and
<code class="docutils literal notranslate"><span class="pre">PFUN(X,'transp')</span></code> returns <code class="docutils literal notranslate"><span class="pre">P’\X</span></code>, approximating <code class="docutils literal notranslate"><span class="pre">A\X</span></code> and <code class="docutils literal notranslate"><span class="pre">A'\X</span></code> respectively.</p></li>
<li><dl class="simple">
<dt>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, it can have one or more of the following fields:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">P.AHA\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.AHA(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">(A'*A)\X</span></code>,
<code class="docutils literal notranslate"><span class="pre">P.AAH\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.AAH(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">(A*A')\X</span></code>,
<code class="docutils literal notranslate"><span class="pre">P.aug\X</span></code> or <code class="docutils literal notranslate"><span class="pre">P.aug(X)</span></code> returns an approximation of <code class="docutils literal notranslate"><span class="pre">[zeros(N,N)</span> <span class="pre">A';A</span> <span class="pre">zeros(M,M)]\X</span></code>.</p>
</dd>
</dl>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is <code class="docutils literal notranslate"><span class="pre">[]</span></code> then no preconditioner is applied.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">primme_svds(A,k,sigma,OPTIONS,P1,P2</span></code>) applies a factorized preconditioner:</p>
<blockquote>
<div><ul class="simple">
<li><p>If both <code class="docutils literal notranslate"><span class="pre">P1</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> are nonempty, apply <code class="docutils literal notranslate"><span class="pre">(P1*P2)\X</span></code> to approximate <code class="docutils literal notranslate"><span class="pre">A\X</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">P1</span></code> is <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> is nonempty, then <code class="docutils literal notranslate"><span class="pre">(P2'*P2)\X</span></code> approximates <code class="docutils literal notranslate"><span class="pre">A'*A</span></code>.
<code class="docutils literal notranslate"><span class="pre">P2</span></code> can be the R factor of an (incomplete) QR factorization of <code class="docutils literal notranslate"><span class="pre">A</span></code> or
the L factor of an (incomplete) LL’ factorization of <code class="docutils literal notranslate"><span class="pre">A'*A</span></code> (RIF).</p></li>
<li><p>If both <code class="docutils literal notranslate"><span class="pre">P1</span></code> and <code class="docutils literal notranslate"><span class="pre">P2</span></code> are <code class="docutils literal notranslate"><span class="pre">[]</span></code> then no preconditioner is applied.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns also the corresponding singular vectors.
If <code class="docutils literal notranslate"><span class="pre">A</span></code> is M-by-N and <code class="docutils literal notranslate"><span class="pre">k</span></code> singular triplets are computed, then <code class="docutils literal notranslate"><span class="pre">U</span></code> is M-by-k
with orthonormal columns, <code class="docutils literal notranslate"><span class="pre">S</span></code> is k-by-k diagonal, and <code class="docutils literal notranslate"><span class="pre">V</span></code> is N-by-k with
orthonormal columns.</p>
<p><code class="docutils literal notranslate"><span class="pre">[S,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the residual norm
of each <code class="docutils literal notranslate"><span class="pre">k</span></code> triplet, <code class="docutils literal notranslate"><span class="pre">NORM([A*V(:,i)-S(i,i)*U(:,i);</span> <span class="pre">A'*U(:,i)-S(i,i)*V(:,i)])</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R,STATS]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns how many times <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> were
used and elapsed time. The application of <code class="docutils literal notranslate"><span class="pre">A</span></code> is counted independently from
the application of <code class="docutils literal notranslate"><span class="pre">A'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">[U,S,V,R,STATS,HIST]</span> <span class="pre">=</span> <span class="pre">primme_svds(...)</span></code> returns the convergence history,
instead of printing it. Every row is a record, and the columns report:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,1)</span></code>: number of matvecs</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,2)</span></code>: time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,3)</span></code>: number of converged/locked triplets</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,4)</span></code>: stage</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,5)</span></code>: block index</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,6)</span></code>: approximate singular value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,7)</span></code>: residual norm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HIST(:,8)</span></code>: QMR residual norm</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">OPTS.reportLevel</span></code> controls the granularity of the record. If <code class="docutils literal notranslate"><span class="pre">OPTS.reportLevel</span> <span class="pre">==</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">HIST</span></code>
has one row per converged eigenpair and only the first three columns
together with the fifth and the sixth are reported. If <code class="docutils literal notranslate"><span class="pre">OPTS.reportLevel</span> <span class="pre">==</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">HIST</span></code>
has one row per outer iteration and converged value, and only the first six
columns are reported. Otherwise <code class="docutils literal notranslate"><span class="pre">HIST</span></code> has one row per QMR iteration, outer
iteration and converged value, and all columns are reported.</p>
<p>The convergence history is displayed if <code class="docutils literal notranslate"><span class="pre">OPTS.reportLevel</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and either <code class="docutils literal notranslate"><span class="pre">HIST</span></code> is
not returned or <code class="docutils literal notranslate"><span class="pre">OPTS.display</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>Examples:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">);</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c">% rectangular matrix of size 200x50</span>

<span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c">% the 10 largest singular values</span>

<span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">)</span><span class="w"> </span><span class="c">% the 10 smallest singular values</span>

<span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">25</span><span class="p">)</span><span class="w"> </span><span class="c">% the 10 closest singular values to 25</span>

<span class="n">opts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">();</span>
<span class="n">opts</span><span class="p">.</span><span class="n">tol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">1e-4</span><span class="p">;</span><span class="w"> </span><span class="c">% set tolerance</span>
<span class="n">opts</span><span class="p">.</span><span class="n">method</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;primme_svds_normalequations&#39;</span><span class="w"> </span><span class="c">% set svd solver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">method</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;DEFAULT_MIN_TIME&#39;</span><span class="w"> </span><span class="c">% set first stage eigensolver method</span>
<span class="n">opts</span><span class="p">.</span><span class="n">primme</span><span class="p">.</span><span class="n">maxBlockSize</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c">% set block size for first stage</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">);</span><span class="w"> </span><span class="c">% find 10 smallest svd triplets</span>

<span class="n">opts</span><span class="p">.</span><span class="n">orthoConst</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">{</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">};</span>
<span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">rnorms</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="n">opts</span><span class="p">)</span><span class="w"> </span><span class="c">% find another 10</span>

<span class="c">% Compute the 5 smallest singular values of a rectangular matrix using</span>
<span class="c">% Jacobi preconditioner on (A&#39;*A)</span>
<span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sparse</span><span class="p">(</span><span class="nb">diag</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">diag</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">49</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="n">A</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c">% size(A)=[200 50]</span>
<span class="n">P</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">diag</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span>
<span class="n">precond</span><span class="p">.</span><span class="n">AHA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">@(</span><span class="n">x</span><span class="p">)</span><span class="n">P</span><span class="o">\</span><span class="n">x</span><span class="p">;</span>
<span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,[],</span><span class="n">precond</span><span class="p">)</span><span class="w"> </span><span class="c">% find the 5 smallest values</span>

<span class="c">% Estimation of the smallest singular value</span>
<span class="n">A</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">diag</span><span class="p">([</span><span class="mi">1</span><span class="w"> </span><span class="nb">repmat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="mi">100</span><span class="p">]);</span>
<span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="n">sval</span><span class="p">,</span><span class="o">~</span><span class="p">,</span><span class="n">rnorm</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">primme_svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="nb">struct</span><span class="p">(</span><span class="s">&#39;convTestFun&#39;</span><span class="p">,@(</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="n">r</span><span class="o">&lt;</span><span class="n">s</span><span class="o">*</span><span class="mf">.1</span><span class="p">));</span>
<span class="n">sval</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">rnorm</span><span class="w"> </span><span class="c">% approximate smallest singular value</span>
</pre></div>
</div>
<p>See also: <a class="reference external" href="https://www.mathworks.com/help/matlab/ref/svds.html">MATLAB svds</a>, <code class="xref mat mat-func docutils literal notranslate"><span class="pre">primme_eigs()</span></code></p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pysvds.html" class="btn btn-neutral float-left" title="Python Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="appendixsvds.html" class="btn btn-neutral float-right" title="Parameter Description" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, College of William &amp; Mary.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>